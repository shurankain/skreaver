use skreaver_core::{Agent, ExecutionResult, MemoryUpdate, ToolCall};
use skreaver_tools::ToolRegistry;
use std::fmt::Display;

/// Central runtime coordinator for agent execution.
///
/// `Coordinator` orchestrates the interaction between agents, tools, and memory
/// systems. It manages the complete lifecycle of agent operations including
/// observation processing, tool dispatch, and memory persistence.
///
/// # Type Parameters
///
/// * `A` - The agent type implementing the `Agent` trait
/// * `R` - The tool registry type implementing the `ToolRegistry` trait
///
/// # Example
///
/// ```rust
/// use skreaver_core::{Agent, MemoryUpdate};
/// use skreaver_core::InMemoryMemory;
/// use skreaver_core::memory::{MemoryReader, MemoryWriter};
/// use skreaver_tools::{InMemoryToolRegistry, ExecutionResult, ToolCall};
/// use skreaver_http::runtime::Coordinator;
///
/// struct SimpleAgent {
///     memory: InMemoryMemory,
/// }
///
/// impl Agent for SimpleAgent {
///     type Observation = String;
///     type Action = String;
///
///     fn memory_reader(&self) -> &dyn MemoryReader { &self.memory }
///     fn memory_writer(&mut self) -> &mut dyn MemoryWriter { &mut self.memory }
///     fn observe(&mut self, input: String) { /* implementation */ }
///     fn act(&mut self) -> String { "response".to_string() }
///     fn call_tools(&self) -> Vec<ToolCall> { Vec::new() }
///     fn handle_result(&mut self, _result: ExecutionResult) {}
///     fn update_context(&mut self, update: MemoryUpdate) { let _ = self.memory_writer().store(update); }
/// }
///
/// let agent = SimpleAgent { memory: InMemoryMemory::new() };
/// let registry = InMemoryToolRegistry::new();
/// let mut coordinator = Coordinator::new(agent, registry);
/// ```
pub struct Coordinator<A: Agent, R: ToolRegistry>
where
    A::Observation: Display,
{
    /// The agent being coordinated.
    ///
    /// This field is public to allow direct access to agent state when needed,
    /// though most operations should go through the coordinator methods.
    pub agent: A,

    /// The tool registry for dispatching tool calls.
    ///
    /// This field is public to allow direct registry operations when needed,
    /// though tool dispatch should typically use coordinator methods.
    pub registry: R,
}

impl<A: Agent, R: ToolRegistry> Coordinator<A, R>
where
    A::Observation: Display,
{
    /// Create a new coordinator with an agent and tool registry.
    ///
    /// # Parameters
    ///
    /// * `agent` - The agent instance to coordinate
    /// * `registry` - The tool registry for dispatching tool calls
    ///
    /// # Returns
    ///
    /// A new `Coordinator` instance ready for execution
    pub fn new(agent: A, registry: R) -> Self {
        Self { agent, registry }
    }

    /// Execute a complete agent step: observe, use tools, and act.
    ///
    /// This is the primary method for agent interaction. It performs the full
    /// agent lifecycle: processes the observation, executes any requested tools,
    /// and generates the final action/response.
    ///
    /// # Parameters
    ///
    /// * `observation` - The input data for the agent to process
    ///
    /// # Returns
    ///
    /// The action/response generated by the agent after processing
    pub fn step(&mut self, observation: A::Observation) -> A::Action {
        self.agent.observe(observation);

        let tool_calls = self.agent.call_tools();

        // Pre-allocate with capacity if we know tools will fail
        let mut failed_tools = Vec::with_capacity(tool_calls.len());

        for tool_call in &tool_calls {
            if let Some(result) = self.registry.dispatch_ref(tool_call) {
                self.agent.handle_result(result);
            } else {
                let tool_name = tool_call.name();
                failed_tools.push(tool_name.to_string());
                tracing::warn!(
                    tool_name = %tool_name,
                    "Tool not found in registry"
                );

                // Pre-allocate error message with exact capacity
                let mut error_msg = String::with_capacity(tool_name.len() + 28);
                error_msg.push_str("Tool '");
                error_msg.push_str(tool_name);
                error_msg.push_str("' not found in registry");

                self.agent
                    .handle_result(ExecutionResult::failure(error_msg));
            }
        }

        self.agent.act()
    }

    /// Update the agent's context with new information.
    ///
    /// Provides a way to inject additional context or configuration
    /// into the agent's memory system outside of the normal observation flow.
    ///
    /// # Parameters
    ///
    /// * `update` - The memory update containing new context data
    pub fn update_context(&mut self, update: MemoryUpdate) {
        self.agent.update_context(update);
    }

    /// Process an observation without executing tools or generating actions.
    ///
    /// This method provides fine-grained control over the agent lifecycle,
    /// allowing observation processing to be separated from tool execution.
    ///
    /// # Parameters
    ///
    /// * `observation` - The input data for the agent to process
    pub fn observe(&mut self, observation: A::Observation) {
        self.agent.observe(observation);
    }

    /// Get the current tool calls requested by the agent.
    ///
    /// Returns the list of tools the agent wants to execute based on its
    /// current state and recent observations. Does not execute the tools.
    ///
    /// # Returns
    ///
    /// Vector of tool calls requested by the agent
    pub fn get_tool_calls(&self) -> Vec<ToolCall> {
        self.agent.call_tools()
    }

    /// Dispatch a single tool call through the registry.
    ///
    /// Executes a specific tool call and returns the result. This provides
    /// fine-grained control over tool execution order and error handling.
    ///
    /// # Parameters
    ///
    /// * `tool_call` - The tool call to execute
    ///
    /// # Returns
    ///
    /// `Some(ExecutionResult)` if the tool exists, `None` if not found
    pub fn dispatch_tool(&self, tool_call: ToolCall) -> Option<ExecutionResult> {
        self.registry.dispatch(tool_call)
    }

    /// Dispatch a single tool call through the registry using a reference.
    ///
    /// Zero-copy version that executes a tool call without taking ownership.
    /// This eliminates cloning in hot paths for better performance.
    ///
    /// # Parameters
    ///
    /// * `tool_call` - Reference to the tool call to execute
    ///
    /// # Returns
    ///
    /// `Some(ExecutionResult)` if the tool exists, `None` if not found
    pub fn dispatch_tool_ref(&self, tool_call: &ToolCall) -> Option<ExecutionResult> {
        self.registry.dispatch_ref(tool_call)
    }

    /// Handle a tool execution result.
    ///
    /// Provides the agent with the results of a tool execution, allowing
    /// it to update its state and potentially influence future tool calls.
    ///
    /// # Parameters
    ///
    /// * `result` - The execution result from a tool
    pub fn handle_tool_result(&mut self, result: ExecutionResult) {
        self.agent.handle_result(result);
    }

    /// Generate an action based on the agent's current state.
    ///
    /// Produces the agent's response or action without processing new
    /// observations or executing tools. Useful for getting intermediate
    /// responses during multi-step processes.
    ///
    /// # Returns
    ///
    /// The action/response generated by the agent
    pub fn get_action(&mut self) -> A::Action {
        self.agent.act()
    }
}
