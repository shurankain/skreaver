use crate::memory::{MemoryReader, MemoryUpdate, MemoryWriter};
use crate::tool::{ExecutionResult, ToolCall};

/// Core trait defining the behavior of an autonomous agent.
///
/// Agents are the primary entities in the Skreaver framework that can observe
/// their environment, reason about observations, use tools, and take actions.
/// They maintain persistent memory and can coordinate with other agents through
/// the runtime system.
///
/// # Lifecycle
///
/// 1. **Observe** - Process incoming data from the environment
/// 2. **Reason** - Determine what tools (if any) need to be called
/// 3. **Act** - Execute tools and generate final response
/// 4. **Update** - Store results and context in memory
///
/// # Example
///
/// ```rust
/// use skreaver_core::{Agent, MemoryReader, MemoryWriter, MemoryUpdate};
/// use skreaver_core::InMemoryMemory;
/// use skreaver_core::tool::{ExecutionResult, ToolCall};
///
/// struct EchoAgent {
///     memory: InMemoryMemory,
///     last_input: Option<String>,
/// }
///
/// impl Agent for EchoAgent {
///     type Observation = String;
///     type Action = String;
///
///     fn memory_reader(&self) -> &dyn MemoryReader {
///         &self.memory
///     }
///
///     fn memory_writer(&mut self) -> &mut dyn MemoryWriter {
///         &mut self.memory
///     }
///
///     fn observe(&mut self, input: String) {
///         self.last_input = Some(input);
///     }
///
///     fn act(&mut self) -> String {
///         self.last_input.clone().unwrap_or_default()
///     }
///
///     fn call_tools(&self) -> Vec<ToolCall> {
///         // Example: return empty vec (no tools needed)
///         Vec::new()
///     }
///
///     fn update_context(&mut self, update: MemoryUpdate) {
///         let _ = self.memory_writer().store(update);
///     }
/// }
/// ```
pub trait Agent {
    /// The type of observations this agent can process.
    ///
    /// This represents the input data format that the agent expects
    /// from its environment or users.
    type Observation;

    /// The type of actions this agent can produce.
    ///
    /// This represents the output format that the agent generates
    /// after processing observations and potentially using tools.
    type Action;

    /// Returns an immutable reference to the agent's memory for read-only operations.
    ///
    /// This method enables concurrent read access to memory without requiring
    /// exclusive mutable access. Agents can use this for context retrieval
    /// and state queries that don't modify memory contents.
    fn memory_reader(&self) -> &dyn MemoryReader;

    /// Returns a mutable reference to the agent's memory for write operations.
    ///
    /// Memory provides persistent storage for agent state, context,
    /// and learned information across interactions. This method should be used
    /// sparingly and only when memory needs to be modified.
    fn memory_writer(&mut self) -> &mut dyn MemoryWriter;

    /// Process an observation from the environment.
    ///
    /// This method is called when new input data is available for the agent
    /// to process. The agent should update its internal state based on the
    /// observation and prepare for potential tool usage or action generation.
    ///
    /// # Parameters
    ///
    /// * `input` - The observation data to process
    fn observe(&mut self, input: Self::Observation);

    /// Generate an action based on current state and observations.
    ///
    /// This method is called after observation processing and tool execution
    /// to produce the agent's final response or action.
    ///
    /// # Returns
    ///
    /// The action or response generated by the agent
    fn act(&mut self) -> Self::Action;

    /// Update the agent's context with new information.
    ///
    /// This method allows external systems to provide additional context
    /// or configuration updates to the agent's memory system.
    ///
    /// # Parameters
    ///
    /// * `update` - The memory update containing key-value data
    fn update_context(&mut self, update: MemoryUpdate);

    /// Return all tool calls the agent wants to make.
    ///
    /// This method is called by the runtime to determine what external
    /// capabilities the agent needs to invoke. Agents can return:
    /// - Empty vector if no tools are needed
    /// - Single tool call in a vector for simple cases
    /// - Multiple tool calls for complex operations
    ///
    /// # Returns
    ///
    /// Vector of tool calls to be executed by the runtime
    fn call_tools(&self) -> Vec<ToolCall> {
        Vec::new()
    }

    /// Handle the result of a tool execution.
    ///
    /// This method is called by the runtime after a tool has been executed,
    /// allowing the agent to process the results and update its state accordingly.
    ///
    /// # Parameters
    ///
    /// * `result` - The execution result from the tool, containing output and success status
    fn handle_result(&mut self, _result: ExecutionResult) {}
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::memory::{MemoryKey, MemoryReader, MemoryUpdate, MemoryWriter};

    struct DummyMemory {
        store: Vec<(String, String)>,
    }

    impl MemoryReader for DummyMemory {
        fn load(&self, key: &MemoryKey) -> Result<Option<String>, crate::error::MemoryError> {
            Ok(self
                .store
                .iter()
                .find(|(k, _)| k == key.as_str())
                .map(|(_, v)| v.clone()))
        }

        fn load_many(
            &self,
            keys: &[MemoryKey],
        ) -> Result<Vec<Option<String>>, crate::error::MemoryError> {
            Ok(keys
                .iter()
                .map(|key| {
                    self.store
                        .iter()
                        .find(|(k, _)| k == key.as_str())
                        .map(|(_, v)| v.clone())
                })
                .collect())
        }
    }

    impl MemoryWriter for DummyMemory {
        fn store(&mut self, update: MemoryUpdate) -> Result<(), crate::error::MemoryError> {
            self.store
                .push((update.key.as_str().to_string(), update.value));
            Ok(())
        }

        fn store_many(
            &mut self,
            updates: Vec<MemoryUpdate>,
        ) -> Result<(), crate::error::MemoryError> {
            for update in updates {
                self.store
                    .push((update.key.as_str().to_string(), update.value));
            }
            Ok(())
        }
    }

    struct DummyAgent {
        mem: DummyMemory,
        last_observation: Option<String>,
    }

    impl Agent for DummyAgent {
        type Observation = String;
        type Action = String;

        fn memory_reader(&self) -> &dyn MemoryReader {
            &self.mem
        }

        fn memory_writer(&mut self) -> &mut dyn MemoryWriter {
            &mut self.mem
        }

        fn observe(&mut self, input: Self::Observation) {
            self.last_observation = Some(input);
        }

        fn act(&mut self) -> Self::Action {
            self.last_observation
                .as_ref()
                .map(|s| format!("echo: {s}"))
                .unwrap_or_else(|| "no input".into())
        }

        fn update_context(&mut self, update: MemoryUpdate) {
            let _ = self.memory_writer().store(update);
        }
    }

    #[test]
    fn agent_can_store_memory_through_boxed_trait() {
        let mut agent = DummyAgent {
            mem: DummyMemory { store: vec![] },
            last_observation: None,
        };

        let key = MemoryKey::new("k").unwrap();
        agent.update_context(MemoryUpdate::from_validated(key.clone(), "v".to_string()));

        assert_eq!(agent.memory_reader().load(&key).unwrap(), Some("v".into()));
    }
}
