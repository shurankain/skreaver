//! MCP Tasks support (2025-11-25 spec)
//!
//! Tasks provide durable state machines for long-running operations with
//! polling and deferred result retrieval. Any request can be augmented with
//! a task that allows the client to query status and retrieve results later.
//!
//! ## Task Lifecycle
//!
//! ```text
//! working → input_required | completed | failed | cancelled
//! input_required → working | completed | failed | cancelled
//! completed, failed, cancelled → (terminal, no transitions)
//! ```
//!
//! ## Usage
//!
//! ```rust,ignore
//! use skreaver_mcp::tasks::{McpTaskManager, McpTaskStatus};
//!
//! let manager = McpTaskManager::new();
//!
//! // Create a task for a long-running tool call
//! let task_id = manager.create_task(Some(60_000)).await;
//!
//! // Update status as work progresses
//! manager.update_status(&task_id, McpTaskStatus::Working, Some("Processing...")).await?;
//!
//! // Complete with result
//! manager.complete(&task_id, serde_json::json!({"result": "done"})).await?;
//! ```

use crate::error::{McpError, McpResult};
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use tracing::{debug, warn};

/// MCP task status (mirrors rmcp::model::TaskStatus)
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub enum McpTaskStatus {
    /// Receiver accepted and is working on the request
    Working,
    /// Receiver needs additional input before continuing
    InputRequired,
    /// Operation completed successfully, result is ready
    Completed,
    /// Operation failed and will not continue
    Failed,
    /// Task was cancelled and will not continue
    Cancelled,
}

impl McpTaskStatus {
    /// Whether this status is terminal (no further transitions)
    pub fn is_terminal(self) -> bool {
        matches!(
            self,
            McpTaskStatus::Completed | McpTaskStatus::Failed | McpTaskStatus::Cancelled
        )
    }
}

impl std::fmt::Display for McpTaskStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            McpTaskStatus::Working => write!(f, "working"),
            McpTaskStatus::InputRequired => write!(f, "inputRequired"),
            McpTaskStatus::Completed => write!(f, "completed"),
            McpTaskStatus::Failed => write!(f, "failed"),
            McpTaskStatus::Cancelled => write!(f, "cancelled"),
        }
    }
}

/// An MCP task tracking a long-running operation
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct McpTask {
    /// Unique task identifier (generated by receiver)
    pub task_id: String,
    /// Current lifecycle status
    pub status: McpTaskStatus,
    /// Human-readable status message
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status_message: Option<String>,
    /// ISO-8601 creation timestamp
    pub created_at: DateTime<Utc>,
    /// ISO-8601 last update timestamp
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_updated_at: Option<DateTime<Utc>>,
    /// Retention window in milliseconds
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ttl: Option<u64>,
    /// Suggested polling interval in milliseconds
    #[serde(skip_serializing_if = "Option::is_none")]
    pub poll_interval: Option<u64>,
    /// Task result (stored when completed)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub result: Option<serde_json::Value>,
}

impl McpTask {
    /// Create a new task in working state
    pub fn new(task_id: impl Into<String>, ttl: Option<u64>) -> Self {
        Self {
            task_id: task_id.into(),
            status: McpTaskStatus::Working,
            status_message: None,
            created_at: Utc::now(),
            last_updated_at: None,
            ttl,
            poll_interval: Some(5000), // 5 second default
            result: None,
        }
    }

    /// Whether the task is in a terminal state
    pub fn is_terminal(&self) -> bool {
        self.status.is_terminal()
    }

    /// Whether the task has expired based on TTL
    pub fn is_expired(&self) -> bool {
        if let Some(ttl_ms) = self.ttl {
            let elapsed = Utc::now()
                .signed_duration_since(self.created_at)
                .num_milliseconds();
            elapsed > ttl_ms as i64
        } else {
            false
        }
    }
}

/// Manages MCP tasks for a server
///
/// Tracks task lifecycle, stores results, and handles TTL-based cleanup.
#[derive(Debug, Clone)]
pub struct McpTaskManager {
    tasks: Arc<RwLock<HashMap<String, McpTask>>>,
    default_ttl: Option<u64>,
    default_poll_interval: u64,
}

impl McpTaskManager {
    /// Create a new task manager
    pub fn new() -> Self {
        Self {
            tasks: Arc::new(RwLock::new(HashMap::new())),
            default_ttl: Some(300_000),  // 5 minutes default
            default_poll_interval: 5000, // 5 seconds
        }
    }

    /// Create with custom default TTL (milliseconds)
    pub fn with_default_ttl(mut self, ttl_ms: u64) -> Self {
        self.default_ttl = Some(ttl_ms);
        self
    }

    /// Create with custom default poll interval (milliseconds)
    pub fn with_poll_interval(mut self, interval_ms: u64) -> Self {
        self.default_poll_interval = interval_ms;
        self
    }

    /// Create a new task and return its ID
    pub async fn create_task(&self, ttl: Option<u64>) -> String {
        let task_id = uuid::Uuid::new_v4().to_string();
        let effective_ttl = ttl.or(self.default_ttl);
        let mut task = McpTask::new(&task_id, effective_ttl);
        task.poll_interval = Some(self.default_poll_interval);

        debug!(task_id = %task_id, ttl = ?effective_ttl, "Created MCP task");

        self.tasks.write().await.insert(task_id.clone(), task);
        task_id
    }

    /// Get task info by ID
    pub async fn get_task(&self, task_id: &str) -> McpResult<McpTask> {
        let tasks = self.tasks.read().await;
        tasks
            .get(task_id)
            .cloned()
            .ok_or_else(|| McpError::TaskNotFound(task_id.to_string()))
    }

    /// Update task status
    pub async fn update_status(
        &self,
        task_id: &str,
        status: McpTaskStatus,
        message: Option<String>,
    ) -> McpResult<McpTask> {
        let mut tasks = self.tasks.write().await;
        let task = tasks
            .get_mut(task_id)
            .ok_or_else(|| McpError::TaskNotFound(task_id.to_string()))?;

        if task.is_terminal() {
            return Err(McpError::TaskTerminal(format!(
                "Task {} is already in terminal state: {}",
                task_id, task.status
            )));
        }

        task.status = status;
        task.status_message = message;
        task.last_updated_at = Some(Utc::now());

        debug!(task_id = %task_id, status = %status, "Updated task status");

        Ok(task.clone())
    }

    /// Complete a task with a result
    pub async fn complete(&self, task_id: &str, result: serde_json::Value) -> McpResult<McpTask> {
        let mut tasks = self.tasks.write().await;
        let task = tasks
            .get_mut(task_id)
            .ok_or_else(|| McpError::TaskNotFound(task_id.to_string()))?;

        if task.is_terminal() {
            return Err(McpError::TaskTerminal(format!(
                "Task {} is already in terminal state: {}",
                task_id, task.status
            )));
        }

        task.status = McpTaskStatus::Completed;
        task.status_message = Some("Completed successfully".to_string());
        task.last_updated_at = Some(Utc::now());
        task.result = Some(result);

        debug!(task_id = %task_id, "Task completed");

        Ok(task.clone())
    }

    /// Fail a task with an error message
    pub async fn fail(&self, task_id: &str, error: impl Into<String>) -> McpResult<McpTask> {
        let error_msg = error.into();
        let mut tasks = self.tasks.write().await;
        let task = tasks
            .get_mut(task_id)
            .ok_or_else(|| McpError::TaskNotFound(task_id.to_string()))?;

        if task.is_terminal() {
            return Err(McpError::TaskTerminal(format!(
                "Task {} is already in terminal state: {}",
                task_id, task.status
            )));
        }

        task.status = McpTaskStatus::Failed;
        task.status_message = Some(error_msg);
        task.last_updated_at = Some(Utc::now());

        debug!(task_id = %task_id, "Task failed");

        Ok(task.clone())
    }

    /// Cancel a task
    pub async fn cancel(&self, task_id: &str) -> McpResult<McpTask> {
        let mut tasks = self.tasks.write().await;
        let task = tasks
            .get_mut(task_id)
            .ok_or_else(|| McpError::TaskNotFound(task_id.to_string()))?;

        if task.is_terminal() {
            return Err(McpError::TaskTerminal(format!(
                "Task {} is already in terminal state: {}",
                task_id, task.status
            )));
        }

        task.status = McpTaskStatus::Cancelled;
        task.status_message = Some("Cancelled by requestor".to_string());
        task.last_updated_at = Some(Utc::now());

        debug!(task_id = %task_id, "Task cancelled");

        Ok(task.clone())
    }

    /// Get task result (returns None if not yet completed)
    pub async fn get_result(&self, task_id: &str) -> McpResult<Option<serde_json::Value>> {
        let tasks = self.tasks.read().await;
        let task = tasks
            .get(task_id)
            .ok_or_else(|| McpError::TaskNotFound(task_id.to_string()))?;
        Ok(task.result.clone())
    }

    /// List all tasks with optional pagination
    pub async fn list_tasks(
        &self,
        cursor: Option<&str>,
        limit: usize,
    ) -> (Vec<McpTask>, Option<String>) {
        let tasks = self.tasks.read().await;
        let mut all_tasks: Vec<_> = tasks.values().cloned().collect();

        // Sort by creation time (newest first)
        all_tasks.sort_by(|a, b| b.created_at.cmp(&a.created_at));

        // Apply cursor (skip tasks before cursor position)
        let start = if let Some(cursor) = cursor {
            all_tasks
                .iter()
                .position(|t| t.task_id == cursor)
                .map(|pos| pos + 1)
                .unwrap_or(0)
        } else {
            0
        };

        let page: Vec<_> = all_tasks.into_iter().skip(start).take(limit + 1).collect();

        if page.len() > limit {
            let next_cursor = page[limit - 1].task_id.clone();
            (page.into_iter().take(limit).collect(), Some(next_cursor))
        } else {
            (page, None)
        }
    }

    /// Clean up expired tasks
    pub async fn cleanup_expired(&self) -> usize {
        let mut tasks = self.tasks.write().await;
        let expired: Vec<String> = tasks
            .values()
            .filter(|t| t.is_expired())
            .map(|t| t.task_id.clone())
            .collect();

        let count = expired.len();
        for id in &expired {
            tasks.remove(id);
            debug!(task_id = %id, "Cleaned up expired task");
        }

        if count > 0 {
            warn!(count, "Cleaned up expired MCP tasks");
        }

        count
    }

    /// Get count of active (non-terminal) tasks
    pub async fn active_count(&self) -> usize {
        let tasks = self.tasks.read().await;
        tasks.values().filter(|t| !t.is_terminal()).count()
    }

    /// Get total task count
    pub async fn total_count(&self) -> usize {
        self.tasks.read().await.len()
    }
}

impl Default for McpTaskManager {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_task_lifecycle() {
        let manager = McpTaskManager::new();

        // Create task
        let task_id = manager.create_task(Some(60_000)).await;
        let task = manager.get_task(&task_id).await.unwrap();
        assert_eq!(task.status, McpTaskStatus::Working);
        assert!(!task.is_terminal());

        // Update to input_required
        let task = manager
            .update_status(
                &task_id,
                McpTaskStatus::InputRequired,
                Some("Need data".into()),
            )
            .await
            .unwrap();
        assert_eq!(task.status, McpTaskStatus::InputRequired);

        // Back to working
        let task = manager
            .update_status(&task_id, McpTaskStatus::Working, Some("Processing".into()))
            .await
            .unwrap();
        assert_eq!(task.status, McpTaskStatus::Working);

        // Complete
        let task = manager
            .complete(&task_id, serde_json::json!({"answer": 42}))
            .await
            .unwrap();
        assert_eq!(task.status, McpTaskStatus::Completed);
        assert!(task.is_terminal());

        // Cannot update terminal task
        let err = manager
            .update_status(&task_id, McpTaskStatus::Working, None)
            .await;
        assert!(err.is_err());
    }

    #[tokio::test]
    async fn test_task_cancel() {
        let manager = McpTaskManager::new();

        let task_id = manager.create_task(None).await;
        let task = manager.cancel(&task_id).await.unwrap();
        assert_eq!(task.status, McpTaskStatus::Cancelled);
        assert!(task.is_terminal());

        // Cannot cancel again
        assert!(manager.cancel(&task_id).await.is_err());
    }

    #[tokio::test]
    async fn test_task_fail() {
        let manager = McpTaskManager::new();

        let task_id = manager.create_task(None).await;
        let task = manager
            .fail(&task_id, "Something went wrong")
            .await
            .unwrap();
        assert_eq!(task.status, McpTaskStatus::Failed);
        assert!(task.is_terminal());
    }

    #[tokio::test]
    async fn test_task_result() {
        let manager = McpTaskManager::new();

        let task_id = manager.create_task(None).await;

        // No result yet
        let result = manager.get_result(&task_id).await.unwrap();
        assert!(result.is_none());

        // Complete with result
        manager
            .complete(&task_id, serde_json::json!({"data": "done"}))
            .await
            .unwrap();

        let result = manager.get_result(&task_id).await.unwrap();
        assert!(result.is_some());
        assert_eq!(result.unwrap()["data"], "done");
    }

    #[tokio::test]
    async fn test_task_not_found() {
        let manager = McpTaskManager::new();

        let err = manager.get_task("nonexistent").await;
        assert!(err.is_err());
    }

    #[tokio::test]
    async fn test_list_tasks() {
        let manager = McpTaskManager::new();

        // Create several tasks
        for _ in 0..5 {
            manager.create_task(None).await;
        }

        let (tasks, next_cursor) = manager.list_tasks(None, 3).await;
        assert_eq!(tasks.len(), 3);
        assert!(next_cursor.is_some());

        // Second page
        let (tasks2, next_cursor2) = manager.list_tasks(next_cursor.as_deref(), 3).await;
        assert_eq!(tasks2.len(), 2);
        assert!(next_cursor2.is_none());
    }

    #[tokio::test]
    async fn test_active_count() {
        let manager = McpTaskManager::new();

        let t1 = manager.create_task(None).await;
        let t2 = manager.create_task(None).await;
        let _t3 = manager.create_task(None).await;

        assert_eq!(manager.active_count().await, 3);
        assert_eq!(manager.total_count().await, 3);

        manager
            .complete(&t1, serde_json::json!(null))
            .await
            .unwrap();
        manager.cancel(&t2).await.unwrap();

        assert_eq!(manager.active_count().await, 1);
        assert_eq!(manager.total_count().await, 3);
    }

    #[tokio::test]
    async fn test_cleanup_expired() {
        let manager = McpTaskManager::new();

        // Create a task with 0ms TTL (immediately expired)
        let task_id = manager.create_task(Some(0)).await;

        // Small delay to ensure expiry
        tokio::time::sleep(tokio::time::Duration::from_millis(10)).await;

        assert!(manager.get_task(&task_id).await.unwrap().is_expired());

        let cleaned = manager.cleanup_expired().await;
        assert_eq!(cleaned, 1);
        assert_eq!(manager.total_count().await, 0);
    }

    #[test]
    fn test_task_status_display() {
        assert_eq!(McpTaskStatus::Working.to_string(), "working");
        assert_eq!(McpTaskStatus::InputRequired.to_string(), "inputRequired");
        assert_eq!(McpTaskStatus::Completed.to_string(), "completed");
        assert_eq!(McpTaskStatus::Failed.to_string(), "failed");
        assert_eq!(McpTaskStatus::Cancelled.to_string(), "cancelled");
    }

    #[test]
    fn test_task_status_terminal() {
        assert!(!McpTaskStatus::Working.is_terminal());
        assert!(!McpTaskStatus::InputRequired.is_terminal());
        assert!(McpTaskStatus::Completed.is_terminal());
        assert!(McpTaskStatus::Failed.is_terminal());
        assert!(McpTaskStatus::Cancelled.is_terminal());
    }
}
