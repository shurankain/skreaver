use crate::agent::Agent;
use crate::memory::MemoryUpdate;
use crate::tool::ToolRegistry;
use std::fmt::Display;

/// Central runtime coordinator for agent execution.
///
/// `Coordinator` orchestrates the interaction between agents, tools, and memory
/// systems. It manages the complete lifecycle of agent operations including
/// observation processing, tool dispatch, and memory persistence.
///
/// # Type Parameters
///
/// * `A` - The agent type implementing the `Agent` trait
/// * `R` - The tool registry type implementing the `ToolRegistry` trait
///
/// # Example
///
/// ```rust
/// use skreaver::{Coordinator, Agent, Memory, MemoryUpdate};
/// use skreaver::memory::InMemoryMemory;
/// use skreaver::tool::registry::InMemoryToolRegistry;
/// use skreaver::tool::{ExecutionResult, ToolCall};
///
/// struct SimpleAgent {
///     memory: Box<dyn Memory + Send>,
/// }
///
/// impl Agent for SimpleAgent {
///     type Observation = String;
///     type Action = String;
///
///     fn memory(&mut self) -> &mut dyn Memory { &mut *self.memory }
///     fn observe(&mut self, input: String) { /* implementation */ }
///     fn act(&mut self) -> String { "response".to_string() }
///     fn update_context(&mut self, update: MemoryUpdate) { self.memory().store(update); }
/// }
///
/// let agent = SimpleAgent { memory: Box::new(InMemoryMemory::new()) };
/// let registry = InMemoryToolRegistry::new();
/// let mut coordinator = Coordinator::new(agent, registry);
/// ```
pub struct Coordinator<A: Agent, R: ToolRegistry>
where
    A::Observation: Display,
{
    /// The agent being coordinated.
    ///
    /// This field is public to allow direct access to agent state when needed,
    /// though most operations should go through the coordinator methods.
    pub agent: A,

    /// The tool registry for dispatching tool calls.
    ///
    /// This field is public to allow direct registry operations when needed,
    /// though tool dispatch should typically use coordinator methods.
    pub registry: R,
}

impl<A: Agent, R: ToolRegistry> Coordinator<A, R>
where
    A::Observation: Display,
{
    /// Create a new coordinator with an agent and tool registry.
    ///
    /// # Parameters
    ///
    /// * `agent` - The agent instance to coordinate
    /// * `registry` - The tool registry for dispatching tool calls
    ///
    /// # Returns
    ///
    /// A new `Coordinator` instance ready for execution
    pub fn new(agent: A, registry: R) -> Self {
        Self { agent, registry }
    }

    /// Execute a complete agent step: observe, use tools, and act.
    ///
    /// This is the primary method for agent interaction. It performs the full
    /// agent lifecycle: processes the observation, executes any requested tools,
    /// and generates the final action/response.
    ///
    /// # Parameters
    ///
    /// * `observation` - The input data for the agent to process
    ///
    /// # Returns
    ///
    /// The action/response generated by the agent after processing
    pub fn step(&mut self, observation: A::Observation) -> A::Action {
        self.agent.memory().store(MemoryUpdate {
            key: "input".to_string(),
            value: format!("{observation}"),
        });

        self.agent.observe(observation);

        let tool_calls = self.agent.call_tools();
        let mut failed_tools = Vec::new();
        
        for tool_call in tool_calls {
            if let Some(result) = self.registry.dispatch(tool_call.clone()) {
                self.agent.handle_result(result);
            } else {
                failed_tools.push(tool_call.name.clone());
                tracing::warn!(
                    tool_name = %tool_call.name,
                    "Tool not found in registry"
                );
                
                // Provide failure feedback to the agent
                self.agent.handle_result(crate::tool::ExecutionResult::failure(
                    format!("Tool '{}' not found in registry", tool_call.name)
                ));
            }
        }

        self.agent.act()
    }

    /// Update the agent's context with new information.
    ///
    /// Provides a way to inject additional context or configuration
    /// into the agent's memory system outside of the normal observation flow.
    ///
    /// # Parameters
    ///
    /// * `update` - The memory update containing new context data
    pub fn update_context(&mut self, update: MemoryUpdate) {
        self.agent.memory().store(update.clone());
        self.agent.update_context(update);
    }

    /// Process an observation without executing tools or generating actions.
    ///
    /// This method provides fine-grained control over the agent lifecycle,
    /// allowing observation processing to be separated from tool execution.
    ///
    /// # Parameters
    ///
    /// * `observation` - The input data for the agent to process
    pub fn observe(&mut self, observation: A::Observation) {
        self.agent.observe(observation);
    }

    /// Get the current tool calls requested by the agent.
    ///
    /// Returns the list of tools the agent wants to execute based on its
    /// current state and recent observations. Does not execute the tools.
    ///
    /// # Returns
    ///
    /// Vector of tool calls requested by the agent
    pub fn get_tool_calls(&self) -> Vec<crate::tool::ToolCall> {
        self.agent.call_tools()
    }

    /// Dispatch a single tool call through the registry.
    ///
    /// Executes a specific tool call and returns the result. This provides
    /// fine-grained control over tool execution order and error handling.
    ///
    /// # Parameters
    ///
    /// * `tool_call` - The tool call to execute
    ///
    /// # Returns
    ///
    /// `Some(ExecutionResult)` if the tool exists, `None` if not found
    pub fn dispatch_tool(
        &self,
        tool_call: crate::tool::ToolCall,
    ) -> Option<crate::tool::ExecutionResult> {
        self.registry.dispatch(tool_call)
    }

    /// Handle a tool execution result.
    ///
    /// Provides the agent with the results of a tool execution, allowing
    /// it to update its state and potentially influence future tool calls.
    ///
    /// # Parameters
    ///
    /// * `result` - The execution result from a tool
    pub fn handle_tool_result(&mut self, result: crate::tool::ExecutionResult) {
        self.agent.handle_result(result);
    }

    /// Generate an action based on the agent's current state.
    ///
    /// Produces the agent's response or action without processing new
    /// observations or executing tools. Useful for getting intermediate
    /// responses during multi-step processes.
    ///
    /// # Returns
    ///
    /// The action/response generated by the agent
    pub fn get_action(&mut self) -> A::Action {
        self.agent.act()
    }
}
