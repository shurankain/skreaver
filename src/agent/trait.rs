use crate::memory::{Memory, MemoryUpdate};
use crate::tool::{ExecutionResult, ToolCall};

/// Core trait defining the behavior of an autonomous agent.
///
/// Agents are the primary entities in the Skreaver framework that can observe
/// their environment, reason about observations, use tools, and take actions.
/// They maintain persistent memory and can coordinate with other agents through
/// the runtime system.
///
/// # Lifecycle
///
/// 1. **Observe** - Process incoming data from the environment
/// 2. **Reason** - Determine what tools (if any) need to be called
/// 3. **Act** - Execute tools and generate final response
/// 4. **Update** - Store results and context in memory
///
/// # Example
///
/// ```rust
/// use skreaver::{Agent, Memory, MemoryUpdate};
/// use skreaver::memory::InMemoryMemory;
/// use skreaver::tool::{ExecutionResult, ToolCall};
///
/// struct EchoAgent {
///     memory: Box<dyn Memory + Send>,
///     last_input: Option<String>,
/// }
///
/// impl Agent for EchoAgent {
///     type Observation = String;
///     type Action = String;
///
///     fn memory(&mut self) -> &mut dyn Memory {
///         &mut *self.memory
///     }
///
///     fn observe(&mut self, input: String) {
///         self.last_input = Some(input);
///     }
///
///     fn act(&mut self) -> String {
///         self.last_input.clone().unwrap_or_default()
///     }
///
///     fn update_context(&mut self, update: MemoryUpdate) {
///         self.memory().store(update);
///     }
/// }
/// ```
pub trait Agent {
    /// The type of observations this agent can process.
    ///
    /// This represents the input data format that the agent expects
    /// from its environment or users.
    type Observation;

    /// The type of actions this agent can produce.
    ///
    /// This represents the output format that the agent generates
    /// after processing observations and potentially using tools.
    type Action;

    /// Returns a mutable reference to the agent's memory system.
    ///
    /// Memory provides persistent storage for agent state, context,
    /// and learned information across interactions.
    fn memory(&mut self) -> &mut dyn Memory;

    /// Process an observation from the environment.
    ///
    /// This method is called when new input data is available for the agent
    /// to process. The agent should update its internal state based on the
    /// observation and prepare for potential tool usage or action generation.
    ///
    /// # Parameters
    ///
    /// * `input` - The observation data to process
    fn observe(&mut self, input: Self::Observation);

    /// Generate an action based on current state and observations.
    ///
    /// This method is called after observation processing and tool execution
    /// to produce the agent's final response or action.
    ///
    /// # Returns
    ///
    /// The action or response generated by the agent
    fn act(&mut self) -> Self::Action;

    /// Update the agent's context with new information.
    ///
    /// This method allows external systems to provide additional context
    /// or configuration updates to the agent's memory system.
    ///
    /// # Parameters
    ///
    /// * `update` - The memory update containing key-value data
    fn update_context(&mut self, update: MemoryUpdate);

    /// Return all tool calls the agent wants to make.
    ///
    /// This method is called by the runtime to determine what external
    /// capabilities the agent needs to invoke. The default implementation
    /// collects calls from `call_tool()` for backward compatibility.
    ///
    /// # Returns
    ///
    /// Vector of tool calls to be executed by the runtime
    fn call_tools(&self) -> Vec<ToolCall> {
        self.call_tool().into_iter().collect()
    }

    /// Return a single tool call (deprecated).
    ///
    /// This method is provided for backward compatibility. New implementations
    /// should override `call_tools()` instead for multiple tool support.
    ///
    /// # Returns
    ///
    /// Optional tool call to be executed
    fn call_tool(&self) -> Option<ToolCall> {
        None
    }

    /// Handle the result of a tool execution.
    ///
    /// This method is called by the runtime after a tool has been executed,
    /// allowing the agent to process the results and update its state accordingly.
    ///
    /// # Parameters
    ///
    /// * `result` - The execution result from the tool, containing output and success status
    fn handle_result(&mut self, _result: ExecutionResult) {}
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::memory::{Memory, MemoryUpdate};

    struct DummyMemory {
        store: Vec<(String, String)>,
    }

    impl Memory for DummyMemory {
        fn load(&mut self, key: &str) -> Option<String> {
            self.store
                .iter()
                .find(|(k, _)| k == key)
                .map(|(_, v)| v.clone())
        }

        fn store(&mut self, update: MemoryUpdate) {
            self.store.push((update.key, update.value));
        }
    }

    struct DummyAgent {
        mem: Box<dyn Memory>,
        last_observation: Option<String>,
    }

    impl Agent for DummyAgent {
        type Observation = String;
        type Action = String;

        fn memory(&mut self) -> &mut dyn Memory {
            &mut *self.mem
        }

        fn observe(&mut self, input: Self::Observation) {
            self.last_observation = Some(input);
        }

        fn act(&mut self) -> Self::Action {
            self.last_observation
                .as_ref()
                .map(|s| format!("echo: {s}"))
                .unwrap_or_else(|| "no input".into())
        }

        fn update_context(&mut self, update: MemoryUpdate) {
            self.memory().store(update);
        }
    }

    #[test]
    fn agent_can_store_memory_through_boxed_trait() {
        let mut agent = DummyAgent {
            mem: Box::new(DummyMemory { store: vec![] }),
            last_observation: None,
        };

        agent.update_context(MemoryUpdate {
            key: "k".into(),
            value: "v".into(),
        });

        assert_eq!(agent.memory().load("k"), Some("v".into()));
    }
}
